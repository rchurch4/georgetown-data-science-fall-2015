rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
initial_state
length(initial_state)
target_f
target_f
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate)/target_f(chain[i, ]))
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f)
hmm_1_Y <- hmm_1[,2]
print(head(hmm_1_Y))
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
y = hmm_1_Y)
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
hmm_1_Y)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, ...) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate)/target_f(chain[i, ]))
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
hmm_1_Y)
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
y=hmm_1_Y)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, ...) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, y)/target_f(chain[i, ], y))
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
y=hmm_1_Y)
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
y=hmm_1_Y)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, ...) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, y)/target_f(chain[i, ], y))
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, y) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, y)/target_f(chain[i, ], y))
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
y=hmm_1_Y)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, y) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
# test
print(target_f(candidate, y))
accept <- runif(1) < min(1, target_f(candidate, y)/target_f(chain[i, ], y))
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
y=hmm_1_Y)
initial_state
target_f
hmm_1_Y
initial_state
length(initial_state)
names(hmm_1_Y)
length(hmm_1_Y)
source('~/.active-rstudio-document', echo=TRUE)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, visible_data) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, visible_data)/target_f(chain[i, ], visible_data))
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = hmm_1_Y)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, visible_data) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, visible_data)/target_f(chain[i, ], visible_data))
print(accept)
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = hmm_1_Y)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, visible_data) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
print(visible_data)
accept <- runif(1) < min(1, target_f(candidate, visible_data)/target_f(chain[i, ], visible_data))
print(accept)
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = hmm_1_Y)
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('~/.active-rstudio-document')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
hmm_1[,1]
chain[1, ]
print(target_f(hmm_1[,1], hmm_1[,2]))
hmm_1[,2])
hmm_1[,2]
hmm_1[,1]
hmm_1[,2]
hmm_test <- hmm(P=matrix(c(.98, .02, .02, .98), nrow=2), initial_state=1, N=10)
target_f(hmm_test[,1], hmm_test[,2])
set.seed(1)
hmm_1 <- hmm(P=matrix(c(.98, .02, .02, .98), nrow=2),
initial_state=sample(c(1,2), size=1, prob=c(.5, .5)),
N=10^3)
print(head(hmm_1))
target_f(hmm_1[,1],hmm_1[,2])
1/(2^(1001))
.98^100
.98^1000
head(hmm_1)
# recall our previously simulated hmm
head(hmm_1)
# use this to simulate W(t)
set.seed(1)
initial_state <- sample(hmm_1[,1]) # randomize starting point
visible_data <- sample(hmm_1[,2])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = visible_data)
# recall our previously simulated hmm
head(hmm_1)
# use this to simulate W(t)
set.seed(1)
initial_state <- sample(hmm_1[,1]) # randomize starting point
visible_data <- sample(hmm_1[,2])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = visible_data)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, visible_data) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, visible_data)/target_f(chain[i, ], visible_data))
print(accept)
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
print(visible_data)
return(chain)
}
# recall our previously simulated hmm
head(hmm_1)
# use this to simulate W(t)
set.seed(1)
initial_state <- sample(hmm_1[,1]) # randomize starting point
visible_data <- sample(hmm_1[,2])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = visible_data)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, visible_data) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, visible_data)/target_f(chain[i, ], visible_data))
print(accept)
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# recall our previously simulated hmm
head(hmm_1)
# use this to simulate W(t)
set.seed(1)
initial_state <- sample(hmm_1[,1]) # randomize starting point
visible_data <- sample(hmm_1[,2])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = visible_data)
rm(list=ls())
q()
q()
install.packages(rocr)
install.packages("rocr")
install.packages("cvTools")
require(arules)
install.packages("arules")
require(arules)
install.packages("arulesViz")
q()
logistic_f <- function(t) {
exp(t) / (1+exp(t))
}
plot(seq(-10, 10, .01),
logistic_f(seq(-10, 10, .01)))
plot(seq(-10, 10, .01),
logistic_f(seq(-10, 10, .01)),
cex=.1)
curve(logistic_f)
curve(logistic_f(x))
curve(logistic_f,
from=-10,
to=10)
curve(logistic_f(x),
from=-10,
to=10)
rm(list=ls())
logistic_funk <- function(t) {
return(exp(t) / (1+exp(t)))
}
curve(logistic_funk,
from=-10,
to=10)
curve(logistic_funk,
from=-10,
to=10,
main = expression(sigma (t)))
require("arules")
require("arulesViz")
q()
install.packages("arules")
require("arules")
require("arulesViz")
q()
remove.packages("arules")
installed.packages()
names(installed.packages())
head(installed.packages())
installed.packages()$Package
installed.packages()[,1]
"arules" %in% installed.packages()[,1]
"utils" %in% installed.packages()[,1]
?arules
install.packages("arules")
?arules
?arules
require("arules")
?arules
?arules
require("arules")
?arules
require("arules")
?arules
.libpath()
.libPath()
.libPath
libPath()
libPaths()
.libpaths()
.libPaths()
q()
q)()
n
q()
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Intro_to_Analytics/Project/Git/georgetown-data-science-fall-2015/analysis/parametric_tests/parametric_tests.R')
rm(list=ls())
q()
