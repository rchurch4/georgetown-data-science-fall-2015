chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, y)/target_f(chain[i, ], y))
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
y=hmm_1_Y)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, y) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
# test
print(target_f(candidate, y))
accept <- runif(1) < min(1, target_f(candidate, y)/target_f(chain[i, ], y))
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
y=hmm_1_Y)
initial_state
target_f
hmm_1_Y
initial_state
length(initial_state)
names(hmm_1_Y)
length(hmm_1_Y)
source('~/.active-rstudio-document', echo=TRUE)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, visible_data) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, visible_data)/target_f(chain[i, ], visible_data))
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = hmm_1_Y)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, visible_data) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, visible_data)/target_f(chain[i, ], visible_data))
print(accept)
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = hmm_1_Y)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, visible_data) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
print(visible_data)
accept <- runif(1) < min(1, target_f(candidate, visible_data)/target_f(chain[i, ], visible_data))
print(accept)
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# get an initial state
initial_state <- sample(hmm_1[,1])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = hmm_1_Y)
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('~/.active-rstudio-document')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Stochastic_Simulation/Homework/homework6/knitr/testing_mh_prob_4.R')
hmm_1[,1]
chain[1, ]
print(target_f(hmm_1[,1], hmm_1[,2]))
hmm_1[,2])
hmm_1[,2]
hmm_1[,1]
hmm_1[,2]
hmm_test <- hmm(P=matrix(c(.98, .02, .02, .98), nrow=2), initial_state=1, N=10)
target_f(hmm_test[,1], hmm_test[,2])
set.seed(1)
hmm_1 <- hmm(P=matrix(c(.98, .02, .02, .98), nrow=2),
initial_state=sample(c(1,2), size=1, prob=c(.5, .5)),
N=10^3)
print(head(hmm_1))
target_f(hmm_1[,1],hmm_1[,2])
1/(2^(1001))
.98^100
.98^1000
head(hmm_1)
# recall our previously simulated hmm
head(hmm_1)
# use this to simulate W(t)
set.seed(1)
initial_state <- sample(hmm_1[,1]) # randomize starting point
visible_data <- sample(hmm_1[,2])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = visible_data)
# recall our previously simulated hmm
head(hmm_1)
# use this to simulate W(t)
set.seed(1)
initial_state <- sample(hmm_1[,1]) # randomize starting point
visible_data <- sample(hmm_1[,2])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = visible_data)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, visible_data) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, visible_data)/target_f(chain[i, ], visible_data))
print(accept)
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
print(visible_data)
return(chain)
}
# recall our previously simulated hmm
head(hmm_1)
# use this to simulate W(t)
set.seed(1)
initial_state <- sample(hmm_1[,1]) # randomize starting point
visible_data <- sample(hmm_1[,2])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = visible_data)
#' Metropolis-Hastings implementation specifically for problem 4 in hw 8.
#'
#' @details Version 1
#' @param T length of chain (number of candidate states to propose)
#' @param initial_state As a numeric vector.
#' @return The realized Markov chain as a matrix, each row representing a
#'         a state. Includes the initial state.
#' @example
metropolis_hastings_problem_4 <- function(T, initial_state, target_f, visible_data) {
chain <- matrix(initial_state, ncol=length(initial_state))
colnames(chain) <- paste("Roll", 0:(length(initial_state)-1))
for (i in 1:T) {
candidate <- propose_candidate(chain[i, ])
accept <- runif(1) < min(1, target_f(candidate, visible_data)/target_f(chain[i, ], visible_data))
print(accept)
if (accept) {
chain <- rbind(chain, candidate)
}
else {
chain <- rbind(chain, chain[i, ])
}
}
rownames(chain) <- paste("x_", 0:T, sep="")
return(chain)
}
# recall our previously simulated hmm
head(hmm_1)
# use this to simulate W(t)
set.seed(1)
initial_state <- sample(hmm_1[,1]) # randomize starting point
visible_data <- sample(hmm_1[,2])
test <- metropolis_hastings_problem_4(T = 10,
initial_state = initial_state,
target_f = target_f,
visible_data = visible_data)
rm(list=ls())
q()
q()
install.packages(rocr)
install.packages("rocr")
install.packages("cvTools")
require(arules)
install.packages("arules")
require(arules)
install.packages("arulesViz")
q()
logistic_f <- function(t) {
exp(t) / (1+exp(t))
}
plot(seq(-10, 10, .01),
logistic_f(seq(-10, 10, .01)))
plot(seq(-10, 10, .01),
logistic_f(seq(-10, 10, .01)),
cex=.1)
curve(logistic_f)
curve(logistic_f(x))
curve(logistic_f,
from=-10,
to=10)
curve(logistic_f(x),
from=-10,
to=10)
rm(list=ls())
logistic_funk <- function(t) {
return(exp(t) / (1+exp(t)))
}
curve(logistic_funk,
from=-10,
to=10)
curve(logistic_funk,
from=-10,
to=10,
main = expression(sigma (t)))
require("arules")
require("arulesViz")
q()
install.packages("arules")
require("arules")
require("arulesViz")
q()
remove.packages("arules")
installed.packages()
names(installed.packages())
head(installed.packages())
installed.packages()$Package
installed.packages()[,1]
"arules" %in% installed.packages()[,1]
"utils" %in% installed.packages()[,1]
?arules
install.packages("arules")
?arules
?arules
require("arules")
?arules
?arules
require("arules")
?arules
require("arules")
?arules
.libpath()
.libPath()
.libPath
libPath()
libPaths()
.libpaths()
.libPaths()
q()
remove.packages("arules")
install.packages("C:/Users/Ravi/Downloads/arules_1.2-1.tar.gz", repos = NULL, type="source")
require("arules")   # version 2.2 is needed, which required installing from source
install.packages("C:/Users/Ravi/Downloads/arules_1.2-1.zip", repos = NULL, type="source")
require("arules")
?arules
require("arulesViz")
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Intro_to_Analytics/Project/Git/georgetown-data-science-fall-2015/analysis/association_rules/association_rules.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Intro_to_Analytics/Project/Git/georgetown-data-science-fall-2015/analysis/association_rules/association_rules.R')
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Intro_to_Analytics/Project/Git/georgetown-data-science-fall-2015/analysis/association_rules/association_rules.R')
plot(yelp_rules_1)
inspect(yelp_rules_4)
inspect(yelp_rules_4)
plot(yelp_rules_4)
plot(yelp_rules_1)
plot(yelp_rules_2)
plot(yelp_rules_3)
plot(yelp_rules_4)
inspect(yelp_rules_4)
plot(yelp_rules_4, method="graph", control=list(type="items"))
plot(yelp_rules_4, method="graph", control=list(type="items"))
rm(list=ls())
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Intro_to_Analytics/Project/Git/georgetown-data-science-fall-2015/analysis/association_rules/association_rules_yelp.R')
yelp_rules_5 <- apriori(yelp_data_categorical[ , -5],
parameter = list(minlen=1, supp=.5, conf=0.1),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(yelp_rules_5)
yelp_rules_5 <- apriori(yelp_data_categorical[ , ],
parameter = list(minlen=1, supp=.5, conf=0.1),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(yelp_rules_5)
head(yelp_data_categorical)
tail(yelp_data_categorical)
names(yelp_data_categorical)
head(yelp_data_categorical)
sum(is.na(yelp_data_categorical))
yelp_rules_5 <- apriori(yelp_data_categorical,
parameter = list(minlen=1, supp=.5, conf=0.1),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(yelp_rules_5)
yelp_rules_5
names(yelp_rules_5)
attributes(yelp_rules_5)
yelp_rules_5$quailty
attribute(yelp_rules_5, quality)
attr(yelp_rules_5, quality)
attr(yelp_rules_5, which = "quality")
attribute(yelp_rules_5, which = "quality")
yelp_rules_5 <- apriori(yelp_data_categorical,
parameter = list(minlen=1, supp=.3, conf=0.1),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(yelp_rules_5)
yelp_rules_5 <- apriori(yelp_data_categorical,
parameter = list(minlen=1, supp=.25, conf=0.1),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(yelp_rules_5)
plot(yelp_rules_5)
rm(list=ls())
source('C:/Users/Ravi/Docs/Geekazoid/Courses/Intro_to_Analytics/Project/Git/georgetown-data-science-fall-2015/analysis/association_rules/association_rules_tripadvisor.R')
tripadvisor_data_categorical <- data.frame(user_is_local = as.factor(tripadvisor_data$user_is_local))
head(tripadvisor_data_categorical)
# Explore data
table(tripadvisor_data$user_rating)
tripadvisor_data_categorical$user_rating <- as.factor(tripadvisor_data$user_rating)
head(tripadvisor_data_categorical)
summary(tripadvisor_data$user_num_reviews)
hist(tripadvisor_data$user_num_reviews)
###################
# user_num_reviews
# Explore data
summary(tripadvisor_data$user_num_reviews)
hist(tripadvisor_data$user_num_reviews)
# Bin and add to new data set:
# low: [1 to 16)
# medium: [16 to 93)
# high: [83 and up)
tripadvisor_data_categorical$user_num_reviews <- cut2(x=tripadvisor_data$user_num_reviews,
cut=c(1, 12, 134))
head(tripadvisor_data_categorical)
###################
# user_num_reviews
# Explore data
summary(tripadvisor_data$user_num_reviews)
hist(tripadvisor_data$user_num_reviews)
# Bin and add to new data set:
# low: [1 to 16)
# medium: [16 to 93)
# high: [83 and up)
tripadvisor_data_categorical$user_num_reviews <- cut2(x=tripadvisor_data$user_num_reviews,
cut=c(1, 16, 83))
###################
# user_review_date
# Explore data
table(substring(tripadvisor_data$user_review_date, first=1, last=4))
###################
# Check out the new data set
head(tripadvisor_data_categorical)
attach(tripadvisor_data_categorical)
tripadvisor_rules_1 <- apriori(tripadvisor_data_categorical,
parameter = list(minlen=1, supp=.01, conf=0.75),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(tripadvisor_rules_1)
plot(tripadvisor_rules_1)
inspect(tripadvisor_rules_1)
tripadvisor_rules_1 <- apriori(tripadvisor_data_categorical,
parameter = list(minlen=1, supp=.01, conf=0.50),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(tripadvisor_rules_1)
tripadvisor_rules_1 <- apriori(tripadvisor_data_categorical,
parameter = list(minlen=1, supp=.01, conf=0.30),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(tripadvisor_rules_1)
tripadvisor_rules_1 <- apriori(tripadvisor_data_categorical,
parameter = list(minlen=1, supp=.01, conf=.5),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(tripadvisor_rules_1)
plot(tripadvisor_rules_1)
# Narrowing down by
tripadvisor_rules_1 <- apriori(tripadvisor_data_categorical,
parameter = list(minlen=1, supp=.03, conf=.5),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(tripadvisor_rules_1)
plot(tripadvisor_rules_1)
tripadvisor_rules_1 <- apriori(tripadvisor_data_categorical,
parameter = list(minlen=1, supp=.2, conf=.5),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(tripadvisor_rules_1)
plot(tripadvisor_rules_1)
# Narrowing down by increasing the minimum support, however, shows that
# ratings of 4 or 5, e.g. the higher ratings, are associated with non-local
# users. This is also what we found with the parametric test! E.g. the t-test
# showed that, while the difference was small, indeed there was a statistically
# significant difference in mean user rating between non-local and local, in
# favor of non-local reviews.
tripadvisor_rules_2 <- apriori(tripadvisor_data_categorical,
parameter = list(minlen=1, supp=.2, conf=.5),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(tripadvisor_rules_2)
plot(tripadvisor_rules_2)
tripadvisor_rules_2 <- apriori(tripadvisor_data_categorical,
parameter = list(minlen=1, supp=.4, conf=.1),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(tripadvisor_rules_2)
plot(tripadvisor_rules_2)
# We use one more level of support to mine the most frequent item sets.
tripadvisor_rules_2 <- apriori(tripadvisor_data_categorical,
parameter = list(minlen=1, supp=.3, conf=.1),
appearance = list(rhs=c("user_is_local=FALSE", "user_is_local=TRUE"), default="lhs"),
control = list(verbose=F))
inspect(tripadvisor_rules_2)
plot(tripadvisor_rules_2)
rm(list=ls())
q()
